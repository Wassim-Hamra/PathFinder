<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/static/js/algorithms.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/static/js/algorithms.js" />
              <option name="originalContent" value="// Algorithm execution and visualization functionality for real map routing&#10;class AlgorithmManager {&#10;    constructor() {&#10;        this.currentResults = null;&#10;        this.noControls = false; // flag if controls are absent&#10;&#10;        this.setupEventListeners();&#10;    }&#10;&#10;    setupEventListeners() {&#10;        // Find path button (may not exist in fullscreen minimal mode)&#10;        const findBtn = document.getElementById('findPathBtn');&#10;        if (findBtn) {&#10;            findBtn.addEventListener('click', () =&gt; {&#10;                this.findPath();&#10;            });&#10;        } else {&#10;            this.noControls = true;&#10;        }&#10;&#10;        // Clear selection button&#10;        const clearBtn = document.getElementById('clearSelectionBtn');&#10;        if (clearBtn) {&#10;            clearBtn.addEventListener('click', () =&gt; {&#10;                if (window.leafletMap) {&#10;                    window.leafletMap.clearSelection();&#10;                    window.leafletMap.updateUI();&#10;                }&#10;            });&#10;        }&#10;&#10;        // Complexity / performance buttons&#10;        const complexityBtn = document.getElementById('showComplexityBtn');&#10;        const performanceBtn = document.getElementById('showPerformanceBtn');&#10;        if (complexityBtn) {&#10;            complexityBtn.addEventListener('click', () =&gt; {&#10;                this.showComplexityAnalysis();&#10;            });&#10;        }&#10;        if (performanceBtn) {&#10;            performanceBtn.addEventListener('click', () =&gt; {&#10;                this.showPerformanceMetrics();&#10;            });&#10;        }&#10;    }&#10;&#10;    async findPath() {&#10;        if (!window.leafletMap || !window.leafletMap.isInitialized) {&#10;            this.showError('Map is still loading. Please wait a moment and try again.');&#10;            return;&#10;        }&#10;&#10;        if (!window.leafletMap.selectedStart || !window.leafletMap.selectedEnd) {&#10;            this.showError('Please select start and end points by clicking on the map');&#10;            return;&#10;        }&#10;&#10;        this.showLoading(true);&#10;&#10;        try {&#10;            const algoSelect = document.getElementById('algorithmSelect');&#10;            const algorithm = algoSelect ? algoSelect.value : 'dijkstra';&#10;&#10;            if (algorithm === 'compare') {&#10;                await this.compareRoutes();&#10;            } else {&#10;                await this.findSingleRoute(algorithm);&#10;            }&#10;&#10;        } catch (error) {&#10;            console.error('Error finding path:', error);&#10;            this.showError('Failed to find route: ' + error.message);&#10;        } finally {&#10;            this.showLoading(false);&#10;        }&#10;    }&#10;&#10;    async findSingleRoute(algorithm) {&#10;        const requestData = {&#10;            start: window.leafletMap.selectedStart,&#10;            end: window.leafletMap.selectedEnd,&#10;            algorithm: algorithm,&#10;            use_real_streets: true&#10;        };&#10;&#10;        const response = await fetch('/api/find-route', {&#10;            method: 'POST',&#10;            headers: { 'Content-Type': 'application/json' },&#10;            body: JSON.stringify(requestData)&#10;        });&#10;&#10;        if (!response.ok) {&#10;            throw new Error(`HTTP error! status: ${response.status}`);&#10;        }&#10;&#10;        const result = await response.json();&#10;&#10;        if (result.error) {&#10;            throw new Error(result.error);&#10;        }&#10;&#10;        this.currentResults = result;&#10;&#10;        // Display the route on the map&#10;        if (window.leafletMap &amp;&amp; window.leafletMap.displayRoute) {&#10;            window.leafletMap.displayRoute(result);&#10;        }&#10;&#10;        // Update performance display with real data&#10;        this.updatePerformanceDisplay(result);&#10;&#10;        // Show success message with route details&#10;        this.showSuccess(&#10;            `Route found using ${result.algorithm}! ` +&#10;            `Distance: ${result.total_distance} km, ` +&#10;            `Duration: ${result.duration_minutes} minutes`&#10;        );&#10;    }&#10;&#10;    async compareRoutes() {&#10;        const requestData = {&#10;            start: window.leafletMap.selectedStart,&#10;            end: window.leafletMap.selectedEnd,&#10;            algorithm: 'compare',&#10;            use_real_streets: true&#10;        };&#10;&#10;        const response = await fetch('/api/find-route', {&#10;            method: 'POST',&#10;            headers: { 'Content-Type': 'application/json' },&#10;            body: JSON.stringify(requestData)&#10;        });&#10;&#10;        if (!response.ok) {&#10;            throw new Error(`HTTP error! status: ${response.status}`);&#10;        }&#10;&#10;        const result = await response.json();&#10;&#10;        if (result.error) {&#10;            throw new Error(result.error);&#10;        }&#10;&#10;        this.currentResults = result;&#10;&#10;        // Display comparison routes on the map&#10;        if (window.leafletMap &amp;&amp; window.leafletMap.displayComparison) {&#10;            window.leafletMap.displayComparison(result.dijkstra, result.astar);&#10;        }&#10;&#10;        // Update performance display with comparison data&#10;        this.updateComparisonPerformance(result);&#10;&#10;        // Show comparison details&#10;        const comparison = result.comparison;&#10;        const dijkstra = result.dijkstra;&#10;        const astar = result.astar;&#10;&#10;        let message = `Route comparison completed!&lt;br&gt;`;&#10;        message += `&lt;strong&gt;Dijkstra:&lt;/strong&gt; ${dijkstra.total_distance}km, ${dijkstra.duration_minutes}min, ${dijkstra.nodes_explored} nodes&lt;br&gt;`;&#10;        message += `&lt;strong&gt;A*:&lt;/strong&gt; ${astar.total_distance}km, ${astar.duration_minutes}min, ${astar.nodes_explored} nodes&lt;br&gt;`;&#10;        message += `&lt;strong&gt;Faster algorithm:&lt;/strong&gt; ${comparison.faster_algorithm}&lt;br&gt;`;&#10;        message += `&lt;strong&gt;Shorter path:&lt;/strong&gt; ${comparison.shorter_path}`;&#10;&#10;        this.showSuccess(message);&#10;    }&#10;&#10;    showLoading(show) {&#10;        const btn = document.getElementById('findPathBtn');&#10;        if (show) {&#10;            btn.innerHTML = '&lt;span class=&quot;spinner-border spinner-border-sm me-2&quot;&gt;&lt;/span&gt;Computing Route...';&#10;            btn.disabled = true;&#10;        } else {&#10;            btn.innerHTML = 'Find Route';&#10;            btn.disabled = !(window.leafletMap &amp;&amp; window.leafletMap.hasValidSelection());&#10;        }&#10;    }&#10;&#10;    showSuccess(message) {&#10;        this.showAlert(message, 'success');&#10;    }&#10;&#10;    showError(message) {&#10;        this.showAlert(message, 'danger');&#10;    }&#10;&#10;    showAlert(message, type) {&#10;        // Remove existing alerts&#10;        const existingAlerts = document.querySelectorAll('.alert-custom');&#10;        existingAlerts.forEach(alert =&gt; alert.remove());&#10;&#10;        // Create new alert&#10;        const alertDiv = document.createElement('div');&#10;        alertDiv.className = `alert alert-${type} alert-dismissible fade show alert-custom mt-3`;&#10;        alertDiv.innerHTML = `&#10;            ${message}&#10;            &lt;button type=&quot;button&quot; class=&quot;btn-close&quot; data-bs-dismiss=&quot;alert&quot;&gt;&lt;/button&gt;&#10;        `;&#10;&#10;        // Insert after the buttons&#10;        const buttonsContainer = document.querySelector('.d-grid');&#10;        if (buttonsContainer) {&#10;            buttonsContainer.parentNode.insertBefore(alertDiv, buttonsContainer.nextSibling);&#10;        }&#10;&#10;        // Auto-remove success alerts after 5 seconds&#10;        if (type === 'success') {&#10;            setTimeout(() =&gt; {&#10;                if (alertDiv &amp;&amp; alertDiv.parentNode) {&#10;                    alertDiv.remove();&#10;                }&#10;            }, 5000);&#10;        }&#10;    }&#10;&#10;    showComplexityAnalysis() {&#10;        // Toggle active state&#10;        document.getElementById('showComplexityBtn').classList.add('active');&#10;        document.getElementById('showPerformanceBtn').classList.remove('active');&#10;&#10;        // Show complexity display, hide performance&#10;        document.getElementById('complexityDisplay').style.display = 'block';&#10;        document.getElementById('performanceDisplay').style.display = 'none';&#10;    }&#10;&#10;    showPerformanceMetrics() {&#10;        // Toggle active state&#10;        document.getElementById('showPerformanceBtn').classList.add('active');&#10;        document.getElementById('showComplexityBtn').classList.remove('active');&#10;&#10;        // Show performance display, hide complexity&#10;        document.getElementById('performanceDisplay').style.display = 'block';&#10;        document.getElementById('complexityDisplay').style.display = 'none';&#10;    }&#10;&#10;    updatePerformanceDisplay(result) {&#10;        // Update performance metrics from route result&#10;        if (result.performance_analysis) {&#10;            const analysis = result.performance_analysis.complexity_analysis;&#10;&#10;            document.getElementById('lastRouteAlgorithm').textContent = result.algorithm;&#10;            document.getElementById('lastExecutionTime').textContent = `${analysis.execution_time_ms.toFixed(2)}ms`;&#10;            document.getElementById('lastNodesExplored').textContent = analysis.nodes_explored;&#10;            document.getElementById('lastEfficiency').textContent = `${analysis.efficiency_ratio.toFixed(1)}%`;&#10;&#10;            // Update insights&#10;            const insights = analysis.performance_insights;&#10;            const insightsDiv = document.getElementById('performanceInsights');&#10;&#10;            if (insights &amp;&amp; insights.length &gt; 0) {&#10;                let insightsHtml = '';&#10;                insights.slice(0, 2).forEach(insight =&gt; {&#10;                    insightsHtml += `&lt;div class=&quot;insight-item&quot;&gt;${insight}&lt;/div&gt;`;&#10;                });&#10;                insightsDiv.innerHTML = insightsHtml;&#10;            }&#10;        }&#10;    }&#10;&#10;    updateComparisonPerformance(result) {&#10;        // Update performance metrics for comparison&#10;        const dijkstra = result.dijkstra;&#10;        const astar = result.astar;&#10;        const comparison = result.comparison;&#10;&#10;        // Show comparison in performance display&#10;        const insightsDiv = document.getElementById('performanceInsights');&#10;        insightsDiv.innerHTML = `&#10;            &lt;div class=&quot;insight-item&quot;&gt;&lt;strong&gt;Comparison Results:&lt;/strong&gt;&lt;/div&gt;&#10;            &lt;div class=&quot;insight-item&quot;&gt;Faster: ${comparison.faster_algorithm}&lt;/div&gt;&#10;            &lt;div class=&quot;insight-item&quot;&gt;Shorter: ${comparison.shorter_path}&lt;/div&gt;&#10;            &lt;div class=&quot;insight-item&quot;&gt;Time diff: ${comparison.time_difference.toFixed(2)}ms&lt;/div&gt;&#10;        `;&#10;&#10;        // Update metrics with comparison data&#10;        document.getElementById('lastRouteAlgorithm').textContent = 'Comparison';&#10;        document.getElementById('lastExecutionTime').textContent = `D:${dijkstra.execution_time.toFixed(1)}ms / A*:${astar.execution_time.toFixed(1)}ms`;&#10;        document.getElementById('lastNodesExplored').textContent = `${dijkstra.nodes_explored} / ${astar.nodes_explored}`;&#10;&#10;        // Calculate efficiency ratios&#10;        const dijkstraEfficiency = dijkstra.performance_analysis?.complexity_analysis?.efficiency_ratio || 0;&#10;        const astarEfficiency = astar.performance_analysis?.complexity_analysis?.efficiency_ratio || 0;&#10;        document.getElementById('lastEfficiency').textContent = `${dijkstraEfficiency.toFixed(1)}% / ${astarEfficiency.toFixed(1)}%`;&#10;    }&#10;}&#10;&#10;// Initialize algorithm manager when DOM is loaded&#10;document.addEventListener('DOMContentLoaded', () =&gt; {&#10;    window.algorithmManager = new AlgorithmManager();&#10;&#10;    // Only trigger default view if buttons exist&#10;    const complexityBtn = document.getElementById('showComplexityBtn');&#10;    if (complexityBtn) {&#10;        complexityBtn.click();&#10;    }&#10;});&#10;" />
              <option name="updatedContent" value="// Algorithm execution and visualization functionality for real map routing&#10;class AlgorithmManager {&#10;    constructor() {&#10;        this.currentResults = null;&#10;        this.noControls = false; // flag if controls are absent&#10;&#10;        this.nodeHistory = { dijkstra: [], astar: [] }; // store last 3 node counts per algorithm&#10;        this.maxHistory = 3;&#10;&#10;        this.setupEventListeners();&#10;    }&#10;&#10;    setupEventListeners() {&#10;        // Find path button (may not exist in fullscreen minimal mode)&#10;        const findBtn = document.getElementById('findPathBtn');&#10;        if (findBtn) {&#10;            findBtn.addEventListener('click', () =&gt; {&#10;                this.findPath();&#10;            });&#10;        } else {&#10;            this.noControls = true;&#10;        }&#10;&#10;        // Clear selection button&#10;        const clearBtn = document.getElementById('clearSelectionBtn');&#10;        if (clearBtn) {&#10;            clearBtn.addEventListener('click', () =&gt; {&#10;                if (window.leafletMap) {&#10;                    window.leafletMap.clearSelection();&#10;                    window.leafletMap.updateUI();&#10;                }&#10;            });&#10;        }&#10;&#10;        // Complexity / performance buttons&#10;        const complexityBtn = document.getElementById('showComplexityBtn');&#10;        const performanceBtn = document.getElementById('showPerformanceBtn');&#10;        if (complexityBtn) {&#10;            complexityBtn.addEventListener('click', () =&gt; {&#10;                this.showComplexityAnalysis();&#10;            });&#10;        }&#10;        if (performanceBtn) {&#10;            performanceBtn.addEventListener('click', () =&gt; {&#10;                this.showPerformanceMetrics();&#10;            });&#10;        }&#10;    }&#10;&#10;    async findPath() {&#10;        if (!window.leafletMap || !window.leafletMap.isInitialized) {&#10;            this.showError('Map is still loading. Please wait a moment and try again.');&#10;            return;&#10;        }&#10;&#10;        if (!window.leafletMap.selectedStart || !window.leafletMap.selectedEnd) {&#10;            this.showError('Please select start and end points by clicking on the map');&#10;            return;&#10;        }&#10;&#10;        this.showLoading(true);&#10;&#10;        try {&#10;            const algoSelect = document.getElementById('algorithmSelect');&#10;            const algorithm = algoSelect ? algoSelect.value : 'dijkstra';&#10;&#10;            if (algorithm === 'compare') {&#10;                await this.compareRoutes();&#10;            } else {&#10;                await this.findSingleRoute(algorithm);&#10;            }&#10;&#10;        } catch (error) {&#10;            console.error('Error finding path:', error);&#10;            this.showError('Failed to find route: ' + error.message);&#10;        } finally {&#10;            this.showLoading(false);&#10;        }&#10;    }&#10;&#10;    async findSingleRoute(algorithm) {&#10;        const requestData = {&#10;            start: window.leafletMap.selectedStart,&#10;            end: window.leafletMap.selectedEnd,&#10;            algorithm: algorithm,&#10;            use_real_streets: true&#10;        };&#10;&#10;        const response = await fetch('/api/find-route', {&#10;            method: 'POST',&#10;            headers: { 'Content-Type': 'application/json' },&#10;            body: JSON.stringify(requestData)&#10;        });&#10;&#10;        if (!response.ok) {&#10;            throw new Error(`HTTP error! status: ${response.status}`);&#10;        }&#10;&#10;        const result = await response.json();&#10;&#10;        if (result.error) {&#10;            throw new Error(result.error);&#10;        }&#10;&#10;        this.currentResults = result;&#10;&#10;        // Record node exploration history&#10;        this.recordNodeHistory(result.algorithm, result.nodes_explored || (result.performance_analysis?.complexity_analysis?.nodes_explored));&#10;        this.updateMiniComplexityChart();&#10;&#10;        // Display the route on the map&#10;        if (window.leafletMap &amp;&amp; window.leafletMap.displayRoute) {&#10;            window.leafletMap.displayRoute(result);&#10;        }&#10;&#10;        // Update performance display with real data&#10;        this.updatePerformanceDisplay(result);&#10;&#10;        // Show success message with route details&#10;        this.showSuccess(&#10;            `Route found using ${result.algorithm}! ` +&#10;            `Distance: ${result.total_distance} km, ` +&#10;            `Duration: ${result.duration_minutes} minutes`&#10;        );&#10;    }&#10;&#10;    async compareRoutes() {&#10;        const requestData = {&#10;            start: window.leafletMap.selectedStart,&#10;            end: window.leafletMap.selectedEnd,&#10;            algorithm: 'compare',&#10;            use_real_streets: true&#10;        };&#10;&#10;        const response = await fetch('/api/find-route', {&#10;            method: 'POST',&#10;            headers: { 'Content-Type': 'application/json' },&#10;            body: JSON.stringify(requestData)&#10;        });&#10;&#10;        if (!response.ok) {&#10;            throw new Error(`HTTP error! status: ${response.status}`);&#10;        }&#10;&#10;        const result = await response.json();&#10;&#10;        if (result.error) {&#10;            throw new Error(result.error);&#10;        }&#10;&#10;        this.currentResults = result;&#10;&#10;        // Record both algorithms' node counts&#10;        this.recordNodeHistory('dijkstra', result.dijkstra.nodes_explored || (result.dijkstra.performance_analysis?.complexity_analysis?.nodes_explored));&#10;        this.recordNodeHistory('astar', result.astar.nodes_explored || (result.astar.performance_analysis?.complexity_analysis?.nodes_explored));&#10;        this.updateMiniComplexityChart();&#10;&#10;        // Display comparison routes on the map&#10;        if (window.leafletMap &amp;&amp; window.leafletMap.displayComparison) {&#10;            window.leafletMap.displayComparison(result.dijkstra, result.astar);&#10;        }&#10;&#10;        // Update performance display with comparison data&#10;        this.updateComparisonPerformance(result);&#10;&#10;        // Show comparison details&#10;        const comparison = result.comparison;&#10;        const dijkstra = result.dijkstra;&#10;        const astar = result.astar;&#10;&#10;        let message = `Route comparison completed!&lt;br&gt;`;&#10;        message += `&lt;strong&gt;Dijkstra:&lt;/strong&gt; ${dijkstra.total_distance}km, ${dijkstra.duration_minutes}min, ${dijkstra.nodes_explored} nodes&lt;br&gt;`;&#10;        message += `&lt;strong&gt;A*:&lt;/strong&gt; ${astar.total_distance}km, ${astar.duration_minutes}min, ${astar.nodes_explored} nodes&lt;br&gt;`;&#10;        message += `&lt;strong&gt;Faster algorithm:&lt;/strong&gt; ${comparison.faster_algorithm}&lt;br&gt;`;&#10;        message += `&lt;strong&gt;Shorter path:&lt;/strong&gt; ${comparison.shorter_path}`;&#10;&#10;        this.showSuccess(message);&#10;    }&#10;&#10;    showLoading(show) {&#10;        const btn = document.getElementById('findPathBtn');&#10;        if (show) {&#10;            btn.innerHTML = '&lt;span class=&quot;spinner-border spinner-border-sm me-2&quot;&gt;&lt;/span&gt;Computing Route...';&#10;            btn.disabled = true;&#10;        } else {&#10;            btn.innerHTML = 'Find Route';&#10;            btn.disabled = !(window.leafletMap &amp;&amp; window.leafletMap.hasValidSelection());&#10;        }&#10;    }&#10;&#10;    showSuccess(message) {&#10;        this.showAlert(message, 'success');&#10;    }&#10;&#10;    showError(message) {&#10;        this.showAlert(message, 'danger');&#10;    }&#10;&#10;    showAlert(message, type) {&#10;        // Remove existing alerts&#10;        const existingAlerts = document.querySelectorAll('.alert-custom');&#10;        existingAlerts.forEach(alert =&gt; alert.remove());&#10;&#10;        // Create new alert&#10;        const alertDiv = document.createElement('div');&#10;        alertDiv.className = `alert alert-${type} alert-dismissible fade show alert-custom mt-3`;&#10;        alertDiv.innerHTML = `&#10;            ${message}&#10;            &lt;button type=&quot;button&quot; class=&quot;btn-close&quot; data-bs-dismiss=&quot;alert&quot;&gt;&lt;/button&gt;&#10;        `;&#10;&#10;        // Insert after the buttons&#10;        const buttonsContainer = document.querySelector('.d-grid');&#10;        if (buttonsContainer) {&#10;            buttonsContainer.parentNode.insertBefore(alertDiv, buttonsContainer.nextSibling);&#10;        }&#10;&#10;        // Auto-remove success alerts after 5 seconds&#10;        if (type === 'success') {&#10;            setTimeout(() =&gt; {&#10;                if (alertDiv &amp;&amp; alertDiv.parentNode) {&#10;                    alertDiv.remove();&#10;                }&#10;            }, 5000);&#10;        }&#10;    }&#10;&#10;    showComplexityAnalysis() {&#10;        // Toggle active state&#10;        document.getElementById('showComplexityBtn').classList.add('active');&#10;        document.getElementById('showPerformanceBtn').classList.remove('active');&#10;&#10;        // Show complexity display, hide performance&#10;        document.getElementById('complexityDisplay').style.display = 'block';&#10;        document.getElementById('performanceDisplay').style.display = 'none';&#10;    }&#10;&#10;    showPerformanceMetrics() {&#10;        // Toggle active state&#10;        document.getElementById('showPerformanceBtn').classList.add('active');&#10;        document.getElementById('showComplexityBtn').classList.remove('active');&#10;&#10;        // Show performance display, hide complexity&#10;        document.getElementById('performanceDisplay').style.display = 'block';&#10;        document.getElementById('complexityDisplay').style.display = 'none';&#10;    }&#10;&#10;    recordNodeHistory(algo, value) {&#10;        if (!value || !this.nodeHistory[algo]) return;&#10;        this.nodeHistory[algo].push(value);&#10;        if (this.nodeHistory[algo].length &gt; this.maxHistory) {&#10;            this.nodeHistory[algo].shift();&#10;        }&#10;    }&#10;&#10;    updateMiniComplexityChart() {&#10;        const groups = document.querySelectorAll('.mini-bar-group');&#10;        if (!groups.length) return; // chart not present (e.g., different layout)&#10;&#10;        // Prepare aligned arrays (most recent last). We'll map newest -&gt; first group for immediacy.&#10;        const dj = [...this.nodeHistory.dijkstra];&#10;        const as = [...this.nodeHistory.astar];&#10;        const maxVal = Math.max(1, ...dj, ...as); // avoid division by zero&#10;&#10;        // Reverse so most recent appears in group 1&#10;        const djRev = dj.slice(-this.maxHistory).reverse();&#10;        const asRev = as.slice(-this.maxHistory).reverse();&#10;&#10;        groups.forEach((group, idx) =&gt; {&#10;            const dBar = group.querySelector('.mini-bar.dijkstra-mini');&#10;            const aBar = group.querySelector('.mini-bar.astar-mini');&#10;            const dVal = djRev[idx];&#10;            const aVal = asRev[idx];&#10;&#10;            if (dBar) {&#10;                if (dVal !== undefined) {&#10;                    const pct = Math.max(8, (dVal / maxVal) * 100); // minimum visible height&#10;                    dBar.style.height = pct + '%';&#10;                    dBar.title = `Dijkstra nodes: ${dVal}`;&#10;                } else {&#10;                    dBar.style.height = '0%';&#10;                    dBar.title = 'No data';&#10;                }&#10;            }&#10;            if (aBar) {&#10;                if (aVal !== undefined) {&#10;                    const pct = Math.max(8, (aVal / maxVal) * 100);&#10;                    aBar.style.height = pct + '%';&#10;                    aBar.title = `A* nodes: ${aVal}`;&#10;                } else {&#10;                    aBar.style.height = '0%';&#10;                    aBar.title = 'No data';&#10;                }&#10;            }&#10;&#10;            // Relabel groups dynamically&#10;            const label = group.querySelector('.bar-label');&#10;            if (label) {&#10;                if (dVal !== undefined || aVal !== undefined) {&#10;                    label.textContent = idx === 0 ? 'Latest' : `Run -${idx}`;&#10;                } else {&#10;                    label.textContent = '—';&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    updateComparisonPerformance(result) {&#10;        // Update performance metrics for comparison&#10;        const dijkstra = result.dijkstra;&#10;        const astar = result.astar;&#10;        const comparison = result.comparison;&#10;&#10;        // Show comparison in performance display&#10;        const insightsDiv = document.getElementById('performanceInsights');&#10;        insightsDiv.innerHTML = `&#10;            &lt;div class=&quot;insight-item&quot;&gt;&lt;strong&gt;Comparison Results:&lt;/strong&gt;&lt;/div&gt;&#10;            &lt;div class=&quot;insight-item&quot;&gt;Faster: ${comparison.faster_algorithm}&lt;/div&gt;&#10;            &lt;div class=&quot;insight-item&quot;&gt;Shorter: ${comparison.shorter_path}&lt;/div&gt;&#10;            &lt;div class=&quot;insight-item&quot;&gt;Time diff: ${comparison.time_difference.toFixed(2)}ms&lt;/div&gt;&#10;        `;&#10;&#10;        // Update metrics with comparison data&#10;        document.getElementById('lastRouteAlgorithm').textContent = 'Comparison';&#10;        document.getElementById('lastExecutionTime').textContent = `D:${dijkstra.execution_time.toFixed(1)}ms / A*:${astar.execution_time.toFixed(1)}ms`;&#10;        document.getElementById('lastNodesExplored').textContent = `${dijkstra.nodes_explored} / ${astar.nodes_explored}`;&#10;&#10;        // Calculate efficiency ratios&#10;        const dijkstraEfficiency = dijkstra.performance_analysis?.complexity_analysis?.efficiency_ratio || 0;&#10;        const astarEfficiency = astar.performance_analysis?.complexity_analysis?.efficiency_ratio || 0;&#10;        document.getElementById('lastEfficiency').textContent = `${dijkstraEfficiency.toFixed(1)}% / ${astarEfficiency.toFixed(1)}%`;&#10;&#10;        // After updating metrics also update chart (already handled after recording, keep in case order changes)&#10;        this.updateMiniComplexityChart();&#10;    }&#10;&#10;    updatePerformanceDisplay(result) {&#10;        // Update performance metrics from route result&#10;        if (result.performance_analysis) {&#10;            const analysis = result.performance_analysis.complexity_analysis;&#10;&#10;            document.getElementById('lastRouteAlgorithm').textContent = result.algorithm;&#10;            document.getElementById('lastExecutionTime').textContent = `${analysis.execution_time_ms.toFixed(2)}ms`;&#10;            document.getElementById('lastNodesExplored').textContent = analysis.nodes_explored;&#10;            document.getElementById('lastEfficiency').textContent = `${analysis.efficiency_ratio.toFixed(1)}%`;&#10;&#10;            // Update insights&#10;            const insights = analysis.performance_insights;&#10;            const insightsDiv = document.getElementById('performanceInsights');&#10;&#10;            if (insights &amp;&amp; insights.length &gt; 0) {&#10;                let insightsHtml = '';&#10;                insights.slice(0, 2).forEach(insight =&gt; {&#10;                    insightsHtml += `&lt;div class=&quot;insight-item&quot;&gt;${insight}&lt;/div&gt;`;&#10;                });&#10;                insightsDiv.innerHTML = insightsHtml;&#10;            }&#10;        }&#10;&#10;        // Keep chart fresh after single result updates&#10;        this.updateMiniComplexityChart();&#10;    }&#10;}&#10;&#10;// Initialize algorithm manager when DOM is loaded&#10;document.addEventListener('DOMContentLoaded', () =&gt; {&#10;    window.algorithmManager = new AlgorithmManager();&#10;&#10;    // Only trigger default view if buttons exist&#10;    const complexityBtn = document.getElementById('showComplexityBtn');&#10;    if (complexityBtn) {&#10;        complexityBtn.click();&#10;    }&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>